---
title: "Equations for mean and SD"
author: "Betsy"
date: "30/06/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Mean

This was the equation used to calculate the weighted mean:
$$\large \overline{\mu} = \frac{\sum_{i}^{N} W_i * X_i}{\sum_{i}^{N} W_i}$$
Where $\overline{\mu}$ is the weighted mean, $W_i$ is the weight for a data point, and $X_i$ is the response for a data point.

## Standard Deviation

This was the original equation used to calcualte standard deviation in the figures that we went through this morning:
$$\large S = \sqrt{\frac{1}{\sum_{i}^{N} W_i - 1} * \sum_{i}^{N} W_i * (X_i - \overline{\mu})^2}  $$
Where $W_i$ is the weighted value for data point $i$, $X_i$ is the response value for data point $i$, and $\overline{\mu}$ is the weighted average.

Questions 3, 4, 6, and 7 had responses on a log scale.  For these questions, the $log(X_i)$ was used in the calculations for both the mean and SD.  This means that S was calculated using a log scale for both $X_i$ and $\overline{\mu}$.  When plotting the data, both $\mu$ and $S$ were exponentiated (i.e. $exp(S)$) before being used in a figure.

Questions 5 and 8 had responses as percentages and were not on a log scale.  For these questions, $X_i$ was used and neither the mean or S were exponentiated for use in the plots.

During lunch, Andy and I did some more searching and I decided to try this equations for S as well:
$$\large S = \sqrt{\frac{N}{(N-1)\sum_{i}^{N} W_i} * \sum_{i}^{N} W_i * (X_i - \overline{\mu})^2}  $$
Where N is the number of data points that are above zero (i.e. used to calculate the mean).  I think this may be a better approach because it takes into account the total number of responses we used in these calculations for each species.


## Here is the code I used to calculate the mean and S that you saw this morning:

```{r SurResp, eval = TRUE, echo = TRUE}
###libraries
library(tidyverse)
library(zoo)
library(viridis)
library(scales)

#SurResp <- readRDS("C:/Users/betsy.barber/Work Folders/Documents/Questionnaire/DF of survey responses.RDS")
SurResp <- readRDS("/home/patrick/Documents/AA/CC_et_migrateur/hybrid_model/questionnaire/DF of survey responses.RDS")

### First divide questions into those with log scale and those wihtout log scale:
temp3 <- c(3, 4, 6, 7) #Define questions on log scale
temp4 <- c(5, 8) #Define questions not on log scale
temp5 <- c(temp3, temp4)

AllData <- SurResp %>%
  filter(Question %in% temp5) %>%
  drop_na(Response) %>%
  mutate_at(c("Response", "Conf"), as.numeric) %>%
  mutate(mResponse = case_when(
    Question == 4 ~ 1/Response,
    Question != 4 ~ Response
  )) %>%
  mutate(
    lResponse = case_when(
      Question %in% temp3 ~ log(mResponse), #take log of response
      Question %in% temp4 ~ mResponse)) %>% #for questions without log
  mutate(ResxCon = mResponse * Conf) %>% #without log (response * confidence level)
  mutate(CompResCon = lResponse * Conf) #with log (logresponse * confidence level)

### Now summarize the data for (response * confidence level) and confidence level
  ### Then calculate weighted mean
SumAllData <- AllData %>%
  drop_na(ResxCon)%>%
  filter(Conf > 0) %>%
  group_by(Question, Species) %>%
  summarise_at(c("Conf", "ResxCon", "CompResCon"
                 ), sum) %>%
  mutate(
    WtAve = case_when(
      Question %in% temp3 ~ exp(CompResCon / Conf), #for questions on log scale
      Question %in% temp4 ~ ResxCon / Conf)) #for questions not on log scale
           

### to get a dataframe that has the group weighted average associated with each row of data:
AllT <- inner_join(AllData, SumAllData, by = c("Question", "Species"))
  

### Example of calculation for SD (this is performed for each question in the survey)
  ### Here this only calculates results for question 3
Q3 <- AllT %>%
  filter(Question == 3 & Conf.x > 0) %>%
  drop_na(Response) %>%
  group_by(Species) %>%
  #mutate(xma = (lResponse - log(WtAve))^2) %>% #(xi - u*)^2 -- Use with log scale
  mutate(xma = (mResponse - WtAve)^2) %>% #Use without log scale
  mutate(wxma = xma * Conf.x) %>% #(wi * (xi - u*)^2)
  summarise_at(c("wxma", "Conf.x"), sum) %>% #sum wi*(xi-u*^2) and sum of wi
  mutate(S2 = (1/(Conf.x - 1)) * wxma) %>%
  #mutate(S = exp(sqrt(S2))) #use with log scale
  mutate(S = sqrt(S2)) #use without log scale




### If you want to make the figures:
temp5 <- c(3, 4, 5, 6, 7, 8)
AllList <- list()
AllSum <- list()
AllCnt <- list()
AllSD <- list()
UseSD <- list()
for(i in temp5){
  temp6 <- list()
  temp7 <- list()
temp6 <- AllData %>%
  filter(Question == i) %>%
  drop_na(ResxCon)%>%
  filter(Conf > 0) %>%
  count(Species, Conf, mResponse, name = "N")
temp7 <- SumAllData %>%
  filter(Question == i)
temp8 <- AllData %>%
  filter(Question == i & Conf > 0) %>%
  count(Question, Species)
AllList[[i]] <- temp6
AllSum[[i]] <- temp7
AllCnt[[i]] <- temp8
}

### To calculate the upper and lower limits of SD for each Question:
Q32 <- SumAllData %>%
  filter(Question == 3) %>%
  inner_join(Q3, SumAllData, by = c("Species")) %>%
  mutate(upSD = (WtAve + S)) %>%
  mutate(dnSD = (WtAve - S))


### This is for questions with a log scale on the x-axis
QuantFigLogScale <- function(data1, data2, data3){
  lbls <- setNames(paste(unique(data2$Species), "\nCL:", data2$Conf, " N:", data3$n,
                         "Mean:", round(data2$WtAve), "\U00B1", round(data2$S), "SD"), unique(data2$Species))
  ggplot() + 
    geom_point(data = data1, aes(x = mResponse, y = Conf, size = N, fill = N), 
               alpha = 0.5, shape = 21, color = "black", stroke = 1.5) +
     geom_vline(data = data2, aes(xintercept = WtAve), lty = 2, col = "blue", lwd = 1) +
     geom_rect(data = data2, aes(xmin = dnSD, xmax = upSD, ymin = 0, ymax = 100), color = "lightblue", alpha = 0.25) +
    facet_wrap(~Species, 
               labeller = labeller(Species = setNames(unlist(lbls), unique(data1$Species)))) +
    theme_bw() +
    theme(axis.text = element_text(size = 16), axis.title = element_text(size = 18), 
          title = element_text(size = 18), strip.text.x = element_text(size = 16)) +
    ylim(0, 100) +
    scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x), 
                  labels = trans_format("log10", math_format(10^.x))) +
    scale_size_continuous(range = c(5, 21), breaks = pretty_breaks(4)) +
    scale_fill_viridis(option = "D", breaks = pretty_breaks(4)) +
    guides(fill = guide_legend(), size = guide_legend()) +
    ylab("Confidence Level") +
    xlab("Answer Response (Log Scale)") 
}

### This is for questions without a log scale on the x-axis
QuantFigNotLog <- function(data1, data2, data3){
  lbls <- setNames(paste(unique(data2$Species), "\nCL:", data2$Conf, " N:", data3$n,
                         "Mean:", round(data2$WtAve), "\U00B1", round(data2$S), "SD"), unique(data2$Species))
  ggplot() +
    geom_point(data = data1, aes(x = mResponse, y = Conf, size = N, fill = N),
               alpha = 0.5, shape = 21, color = "black", stroke = 1.5) +
    geom_vline(data = data2, aes(xintercept = WtAve), lty = 2, col = "blue", lwd = 1) +
   geom_rect(data = data2, aes(xmin = dnSD, xmax = upSD, ymin = 0, ymax = 100), color = "lightblue", alpha = 0.25) +
    facet_wrap(~Species,
               labeller = labeller(Species = setNames(unlist(lbls), unique(data1$Species)))) +
    theme_bw() +
    theme(axis.text = element_text(size = 16), axis.title = element_text(size = 18), 
          title = element_text(size = 18), strip.text.x = element_text(size = 16)) +
    ylim(0, 100) +
    scale_size_continuous(range = c(6, 12), breaks = pretty_breaks(4)) +
    scale_fill_viridis(option = "D", breaks = pretty_breaks(4)) +
    guides(fill = guide_legend(), size = guide_legend()) +
    ylab("Confidence Level") +
    xlab("Answer Response") 
}

#To define the order of species:
SppList <- c("Allis Shad","Twaite Shad",
           "River Lamprey", "Sea Lamprey", 
           "Sea Trout", "Salmon", 
           "Smelt", "Sturgeon",
           "Flounder", "Mullet",  "Eel")

#To apply the order of species levels to all necessary df:
AllList[[3]]$Species <- factor(AllList[[3]]$Species, levels = SppList)
AllCnt[[3]]$Species <- factor(AllCnt[[3]]$Species, levels = SppList)
Q32$Species <- factor(Q32$Species, levels = SppList)

#Call function for figure on log scale for question 3
QuantFigLogScale(AllList[[3]], Q32, AllCnt[[3]]) + ggtitle("Minimum Spawning Stock Size")
 

```


