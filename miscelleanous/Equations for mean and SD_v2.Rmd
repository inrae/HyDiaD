---
title: "Equations for mean and SD_v2"
author: "Betsy"
date: "01/07/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Mean

This was the equation used to calculate the weighted mean:
$$\large \overline{\mu} = \frac{\sum_{i}^{N} W_i * X_i}{\sum_{i}^{N} W_i}$$

## Standard Deviation
$$\large S = \sqrt{\frac{N}{(N-1)\sum_{i}^{N} W_i} * \sum_{i}^{N} W_i * (X_i - \overline{\mu})^2}  $$
Where $W_i$ is the weighted value for data point $i$, $X_i$ is the response value for data point $i$, and $\overline{\mu}$ is the weighted average. Here N is the number of data points that are above zero (i.e. used to calculate the mean).  I think this may be a better approach because it takes into account the total number of responses we used in these calculations for each species.

The issue we were having involved calculating the correct upper and lower limits for the graph.  Previously, I was calculating the mean and SD using the logged data, then exponentiating both answers to calculate the upper and lower limits.  This was a mistake, as I needed to calculate the upper and lower limits before exponentiating both the mean and SD.  When we use the latter approach, we get a SD that is scaled to the log scale used in the x-axis, so in the figure the variance looks equal on both sides of the mean.  Also, the ranges of the SD are now reasonable and not too small or too large given the data.

So, here is the corrected code (which is also cleaned up a little better).  I indicated which lines the changes were made, and included the code to make all of the figures.



```{r SurResp, eval = TRUE, echo = TRUE}
###libraries
library(tidyverse)
library(zoo)
library(viridis)
library(scales)

SurResp <- readRDS("C:/Users/betsy.barber/Work Folders/Documents/Questionnaire/DF of survey responses.RDS") #Change path if necessary

#### Step 3: Drop NAs for individual people and species combinations and calculate the response X confidence level column-------
  ### First divide questions into those with log scale and those wihtout log scale and calculate response * confidence row-wise:
temp3 <- c(3, 4, 6, 7)
temp4 <- c(5, 8)
temp5 <- c(temp3, temp4)
AllData <- SurResp %>%
  filter(Question %in% temp5) %>%
  drop_na(Response) %>%
  mutate_at(c("Response", "Conf"), as.numeric) %>%
  mutate(mResponse = case_when(
    Question == 4 ~ 1/Response,
    Question != 4 ~ Response
  )) %>%
  mutate(
    lResponse = case_when(
      Question %in% temp3 ~ log(mResponse),
      Question %in% temp4 ~ mResponse)) %>%
  mutate(ResxCon = mResponse * Conf) %>%
  mutate(CompResCon = lResponse * Conf)

### Now summarize the data for (response * confidence level) and confidence level
  ### Then calculate weighted mean (WtAveSomeLog)
SumAllData <- AllData %>%
  drop_na(ResxCon)%>%
  filter(Conf > 0) %>%
  group_by(Question, Species) %>%
  summarise_at(c("Conf", "ResxCon", "CompResCon"
                 ), sum) %>%
  mutate(
    WtAveSomeLog = case_when(
      Question %in% temp3 ~ (CompResCon / Conf), #for questions on log scale; in the previous version this was exponentiated, but we do not exponentiate yet!
      Question %in% temp4 ~ ResxCon / Conf)) #for questions not on log scale
       
### to get a dataframe that has the group weighted average associated with each row of data:
AllT <- inner_join(AllData, SumAllData, by = c("Question", "Species"))

### For the SD calculation, count the number of samples with CL > 0 that will be used in the equation as N
N <- AllT %>%
  filter(Conf.x > 0) %>%
  drop_na(Response) %>%
  group_by(Species) %>%
  count(Question, Species) %>%
  mutate_at("n", as.numeric)

#Now join N to the dataframe with the summarized data:
SumAllData2 <- inner_join(SumAllData, N, by = c("Question", "Species"))
#Define funciton for use in function below:
expfunc <- function(x){exp(x)}
#Calculate summarized part of SD equation for questions WITH logged data:
  #i is the question you are using the function on
SDSumLog <- function(i){
  AllT %>%
    filter(Question == i & Conf.x > 0) %>%
    drop_na(Response) %>%
    group_by(Species) %>%
    mutate(xma = (lResponse - (WtAveSomeLog))^2) %>% #Both the Response and the weighted average are on a log scale at this point
    mutate(wxma = xma * Conf.x) %>% #(wi * (xi - u*)^2)
    summarise_at(c("wxma", "Conf.x"), sum)
}

#This function calculates the SD (S) as well as the upper and lower limits of SD for questions WITH logged data (for plotting on the figures)
  #i is the question you are using the function on, Q is the resulting dataframe from the function SDSumLog for this question
SDfuncLog <- function(i, Q){ 
  SumAllData2 %>%
    filter(Question == i) %>%
    inner_join(Q, SumAllData2, by = c("Species")) %>%
    mutate(S2 = (n/((n-1) *Conf.x)) * wxma) %>%
    mutate(S = (sqrt(S2))) %>% ## previously I was exponentiating here, then calculting the upper and lower limits.  But we need to calculated upSD and dnSD BEFORE exponentiating
    mutate(upSD = exp(WtAveSomeLog + S)) %>%
    mutate(dnSD = exp(WtAveSomeLog - S)) %>%
    mutate_at("WtAveSomeLog", expfunc) #This exponentiates the weighted mean to a normal scale from the log scale
}

#This function calculates the summarized part of S for the questions WITHOUT logged data (Questions 5 and 8)
SDSumNoLog <- function(i){
  AllT %>%
    filter(Question == i & Conf.x > 0) %>%
    drop_na(Response) %>%
    group_by(Species) %>%
    mutate(xma = (mResponse - (WtAveSomeLog))^2) %>% 
    mutate(wxma = xma * Conf.x) %>% 
    summarise_at(c("wxma", "Conf.x"), sum) 
}

#This function calculates S and the upper and lower limits for questions WITHOUT logged data
SDfuncNoLog <- function(i, Q){
  SumAllData2 %>%
    filter(Question == i) %>%
    inner_join(Q, SumAllData2, by = c("Species")) %>%
    mutate(S2 = (n/((n-1) *Conf.x)) * wxma) %>%
    mutate(S = (sqrt(S2))) %>% 
    mutate(upSD = (WtAveSomeLog + S)) %>%
    mutate(dnSD = (WtAveSomeLog - S))
}


#### Create the figures -----------------------------------
### If you want to make the figures:
temp5 <- c(3, 4, 5, 6, 7, 8)
AllList <- list()
AllCnt <- list()
for(i in temp5){
  temp6 <- list()
  temp7 <- list()
temp6 <- AllData %>%
  filter(Question == i) %>%
  drop_na(ResxCon)%>%
  filter(Conf > 0) %>%
  count(Species, Conf, mResponse, name = "N")
temp8 <- AllData %>%
  filter(Question == i & Conf > 0) %>%
  count(Question, Species)
AllList[[i]] <- temp6
AllCnt[[i]] <- temp8
}

#Specify the order of plots by species
SppList <- c("Allis Shad","Twaite Shad",
             "River Lamprey", "Sea Lamprey", 
             "Sea Trout", "Salmon", 
             "Smelt", "Sturgeon",
             "Flounder", "Mullet",  "Eel")

#Figure when the data is not logged (Questions 5 and 8)
QuantFigNotLog <- function(data1, data2, data3){
  lbls <- setNames(paste(unique(data2$Species), "\nCL:", data2$Conf, " N:", data3$n,
                         "Mean:", round(data2$WtAveSomeLog), "\U00B1", round(data2$S), "SD"), unique(data2$Species))
  ggplot() +
    geom_point(data = data1, aes(x = mResponse, y = Conf, size = N, fill = N),
               alpha = 0.5, shape = 21, color = "black", stroke = 1.5) +
    geom_vline(data = data2, aes(xintercept = WtAveNoneLog), lty = 2, col = "blue", lwd = 1) +
    geom_rect(data = data2, aes(xmin = dnSD, xmax = upSD, ymin = 0, ymax = 100), color = "lightblue", alpha = 0.25) +
    facet_wrap(~Species,
               labeller = labeller(Species = setNames(unlist(lbls), unique(data1$Species)))) +
    theme_bw() +
    theme(axis.text = element_text(size = 16), axis.title = element_text(size = 18), 
          title = element_text(size = 18), strip.text.x = element_text(size = 16)) +
    ylim(0, 100) +
    scale_size_continuous(range = c(6, 12), breaks = pretty_breaks(4)) +
    scale_fill_viridis(option = "D", breaks = pretty_breaks(4)) +
    guides(fill = guide_legend(), size = guide_legend()) +
    ylab("Confidence Level") +
    xlab("Answer Response") 
}

#Figure when data is logged (Questions 3, 4, 6, and 7)
QuantFigLogScale <- function(data1, data2, data3){
  lbls <- setNames(paste(unique(data2$Species), "\nCL:", data2$Conf, " N:", data3$n,
                         "Mean:", round(data2$WtAveSomeLog), "\U00B1", round(data2$S), "SD"), unique(data2$Species))
  ggplot() + 
    geom_point(data = data1, aes(x = mResponse, y = Conf, size = N, fill = N), 
               alpha = 0.5, shape = 21, color = "black", stroke = 1.5) +
    geom_vline(data = data2, aes(xintercept = WtAveSomeLog), lty = 2, col = "blue", lwd = 1) +
    geom_rect(data = data2, aes(xmin = dnSD, xmax = upSD, ymin = 0, ymax = 100), color = "lightblue", alpha = 0.25) +
    facet_wrap(~Species, 
               labeller = labeller(Species = setNames(unlist(lbls), unique(data1$Species)))) +
    theme_bw() +
    theme(axis.text = element_text(size = 16), axis.title = element_text(size = 18), 
          title = element_text(size = 18), strip.text.x = element_text(size = 16)) +
    ylim(0, 100) +
    scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x), 
                  labels = trans_format("log10", math_format(10^.x))) +
    scale_size_continuous(range = c(5, 21), breaks = pretty_breaks(4)) +
    scale_fill_viridis(option = "D", breaks = pretty_breaks(4)) +
    guides(fill = guide_legend(), size = guide_legend()) +
    ylab("Confidence Level") +
    xlab("Answer Response (Log Scale)") 
}


#Q3: logged
Q3 <- SDSumLog(3)
Q32 <- SDfuncLog(3, Q3)
AllList[[3]]$Species <- factor(AllList[[3]]$Species, levels = SppList)
AllCnt[[3]]$Species <- factor(AllCnt[[3]]$Species, levels = SppList)
Q32$Species <- factor(Q32$Species, levels = SppList)
QuantFigLogScale(AllList[[3]], Q32, AllCnt[[3]]) + ggtitle("Minimum Spawning Stock Size") #xlim(0, 0.01) + 

#Q4: logged
Q4 <- SDSumLog(4)
Q42 <- SDfuncLog(4, Q4)
AllList[[4]]$Species <- factor(AllList[[4]]$Species, levels = SppList)
AllCnt[[4]]$Species <- factor(AllCnt[[4]]$Species, levels = SppList)
Q42$Species <- factor(Q42$Species, levels = SppList)
QuantFigLogScale(AllList[[4]], Q42, AllCnt[[4]]) + ggtitle("Fecundity (1 adult / N eggs)") #xlim(0, 0.01) + 

#Q5: not logged
Q5 <- SDSumNoLog(5)
Q52 <- SDfuncNoLog(5, Q5)
AllList[[5]]$Species <- factor(AllList[[5]]$Species, levels = SppList)
AllCnt[[5]]$Species <- factor(AllCnt[[5]]$Species, levels = SppList)
Q52$Species <- factor(Q52$Species, levels = SppList)
QuantFigNotLog(AllList[[5]], Q52, AllCnt[[5]]) + ggtitle("Proportion of emigrant fish (%)")

#Q6: logged
Q6 <- SDSumLog(6)
Q62 <- SDfuncLog(6, Q6)
AllList[[6]]$Species <- factor(AllList[[6]]$Species, levels = SppList)
AllCnt[[6]]$Species <- factor(AllCnt[[6]]$Species, levels = SppList)
Q62$Species <- factor(Q62$Species, levels = SppList)
QuantFigLogScale(data1 = AllList[[6]], data2 = Q62, 
                 data3 = AllCnt[[6]]) + ggtitle("Mean distance emigrant disperses (km)")
#Q7: logged
Q7 <- SDSumLog(7)
Q72 <- SDfuncLog(7, Q7)
AllList[[7]]$Species <- factor(AllList[[7]]$Species, levels = SppList)
AllCnt[[7]]$Species <- factor(AllCnt[[7]]$Species, levels = SppList)
Q72$Species <- factor(Q72$Species, levels = SppList)
QuantFigLogScale(AllList[[7]], Q72, AllCnt[[7]]) + ggtitle("Max distance emigrant disperses (km)")

#Q8: not logged
Q8 <- SDSumNoLog(8)
Q82 <- SDfuncNoLog(8, Q8)
AllList[[8]]$Species <- factor(AllList[[8]]$Species, levels = SppList)
AllCnt[[8]]$Species <- factor(AllCnt[[8]]$Species, levels = SppList)
Q82$Species <- factor(Q82$Species, levels = SppList)
QuantFigNotLog(AllList[[8]], Q82, AllCnt[[8]]) + ggtitle("Emigrant survival (%)")




```